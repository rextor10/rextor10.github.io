<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text-to-DNA Data Storage Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind for Inter font and custom colors -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'dna-a': '#ef4444', // Red
                        'dna-t': '#3b82f6', // Blue
                        'dna-c': '#10b981', // Green
                        'dna-g': '#f59e0b', // Yellow
                    }
                }
            }
        }
    </script>
    <style>
        /* Base styles for the canvas */
        #dnaCanvas {
            border: 2px solid #e5e7eb;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            width: 100%;
            height: 200px;
        }
        /* Style for the button */
        .action-button {
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .action-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">

    <div class="max-w-4xl mx-auto bg-white p-6 md:p-10 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">DNA Data Encoding Simulator</h1>

        <!-- Input Text Section -->
        <div class="mb-8">
            <label for="inputText" class="block text-sm font-medium text-gray-700 mb-2">Original Text Input:</label>
            <textarea id="inputText" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150" rows="3" placeholder="Enter the text to encode (e.g., 'Hello world!')">Hello, Gemini!</textarea>
        </div>

        <!-- Mapping Configuration Section -->
        <div class="mb-8 p-5 bg-blue-50 rounded-lg shadow-inner">
            <h2 class="text-lg font-semibold text-blue-800 mb-3">2-Bit DNA Base Mappings</h2>
            <p class="text-sm text-blue-700 mb-4">Assign a unique 2-bit code (00, 01, 10, 11) to each DNA base.</p>
            <div id="mappingInputs" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <!-- Inputs generated by JS for A, T, C, G -->
            </div>
        </div>

        <!-- Controls and Output Section -->
        <div class="flex flex-col md:flex-row gap-4 mb-8">
            <button id="encodeButton" onclick="handleEncodeAndVisualize()" class="action-button flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg text-center">
                1. Encode & Visualize (Re-Simulate)
            </button>
            <button id="decodeButton" onclick="handleDecode()" class="action-button flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg text-center">
                2. Decode Sequence
            </button>
        </div>

        <!-- DNA Sequence Visualization -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">DNA Sequence Visualization</h2>
            <canvas id="dnaCanvas" width="800" height="200"></canvas>
            <div class="mt-3 p-4 bg-gray-100 rounded-lg text-sm font-mono break-all text-gray-700">
                <span class="font-bold text-gray-900">Sequence String:</span>
                <span id="dnaSequenceOutput" class="ml-2">Awaiting Encoding...</span>
            </div>
            <div class="mt-3">
                <span class="font-bold text-gray-900">Base Colors:</span>
                <span class="inline-block w-4 h-4 rounded-full bg-dna-a ml-2 mr-1"></span> A
                <span class="inline-block w-4 h-4 rounded-full bg-dna-t ml-2 mr-1"></span> T
                <span class="inline-block w-4 h-4 rounded-full bg-dna-c ml-2 mr-1"></span> C
                <span class="inline-block w-4 h-4 rounded-full bg-dna-g ml-2 mr-1"></span> G
            </div>
        </div>

        <!-- Decoded Text Output -->
        <div>
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Decoded Text</h2>
            <div id="decodedTextOutput" class="p-4 min-h-[4rem] bg-amber-100 border-l-4 border-amber-500 rounded-lg text-gray-800 font-medium">
                Awaiting Decoding...
            </div>
        </div>

        <!-- Error/Status Message Box (Hidden by default) -->
        <div id="statusMessage" class="hidden fixed bottom-4 right-4 p-4 text-white rounded-lg shadow-xl z-50 transition-opacity duration-300" role="alert"></div>

    </div>

<script>
    // Global variables for Firebase constants (required by the environment, not used here)
    const __app_id = 'dna-simulator';
    const __firebase_config = '{}';
    const __initial_auth_token = null;

    // --- STATE AND SETUP ---

    const BASES = ['A', 'T', 'C', 'G'];
    const DEFAULT_MAPPING = {
        'A': '00',
        'T': '01',
        'C': '10',
        'G': '11',
    };
    let currentDNASequence = '';
    let currentMapping = { ...DEFAULT_MAPPING };

    const elements = {
        mappingInputs: document.getElementById('mappingInputs'),
        inputText: document.getElementById('inputText'),
        dnaSequenceOutput: document.getElementById('dnaSequenceOutput'),
        decodedTextOutput: document.getElementById('decodedTextOutput'),
        dnaCanvas: document.getElementById('dnaCanvas'),
        statusMessage: document.getElementById('statusMessage'),
        ctx: null,
    };

    // Visualization configuration
    const COLOR_MAP = {
        'A': '#ef4444', // Red
        'T': '#3b82f6', // Blue
        'C': '#10b981', // Green
        'G': '#f59e0b', // Yellow
    };

    /**
     * Shows a non-blocking status message.
     * @param {string} message The message to display.
     * @param {string} type 'success' or 'error'
     */
    function showStatus(message, type) {
        const msgBox = elements.statusMessage;
        msgBox.textContent = message;
        msgBox.className = 'fixed bottom-4 right-4 p-4 text-white rounded-lg shadow-xl z-50 transition-opacity duration-300';

        if (type === 'success') {
            msgBox.classList.add('bg-green-500');
        } else if (type === 'error') {
            msgBox.classList.add('bg-red-500');
        } else {
             msgBox.classList.add('bg-gray-500');
        }
        msgBox.classList.remove('hidden');

        setTimeout(() => {
            msgBox.classList.add('opacity-0');
            setTimeout(() => {
                msgBox.classList.add('hidden');
                msgBox.classList.remove('opacity-0');
            }, 300);
        }, 3000);
    }

    /**
     * Generates and initializes mapping input fields.
     */
    function initMappingInputs() {
        BASES.forEach(base => {
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-center space-x-2';

            const label = document.createElement('label');
            label.setAttribute('for', `map_${base}`);
            label.className = `text-lg font-bold text-gray-700 w-6 text-center rounded-md p-1 bg-white shadow-sm border`;
            label.textContent = base;

            const input = document.createElement('input');
            input.id = `map_${base}`;
            input.type = 'text';
            input.maxLength = 2;
            input.value = DEFAULT_MAPPING[base];
            input.className = 'w-16 p-2 border border-gray-300 rounded-lg text-center font-mono focus:ring-blue-500 focus:border-blue-500';

            wrapper.appendChild(label);
            wrapper.appendChild(input);
            elements.mappingInputs.appendChild(wrapper);
        });
    }

    /**
     * Reads the current mapping from the input fields.
     * @returns {object|null} The current mapping or null if invalid.
     */
    function readCurrentMapping() {
        const newMapping = {};
        const values = new Set();
        let isValid = true;

        BASES.forEach(base => {
            const input = document.getElementById(`map_${base}`);
            const value = input.value.trim();

            if (!['00', '01', '10', '11'].includes(value)) {
                showStatus(`Invalid code for ${base}. Must be '00', '01', '10', or '11'.`, 'error');
                isValid = false;
            } else if (values.has(value)) {
                showStatus(`Code '${value}' is assigned to multiple bases. Mappings must be unique.`, 'error');
                isValid = false;
            }
            newMapping[base] = value;
            values.add(value);
        });

        if (!isValid) return null;
        return newMapping;
    }

    // --- CORE ENCODING/DECODING LOGIC ---

    /**
     * Converts a text string into its full 8-bit binary representation.
     * @param {string} text
     * @returns {string} The concatenated binary string.
     */
    function textToBinary(text) {
        let binary = '';
        for (let i = 0; i < text.length; i++) {
            // Convert character's ASCII code to 8-bit binary string
            binary += text.charCodeAt(i).toString(2).padStart(8, '0');
        }
        return binary;
    }

    /**
     * Converts a binary string to a DNA sequence using the current mapping.
     * @param {string} binary
     * @param {object} mapping The DNA base to 2-bit mapping.
     * @returns {string} The DNA sequence string.
     */
    function binaryToDNA(binary, mapping) {
        let dna = '';
        // Find the reverse mapping (2-bit code -> DNA base) for efficient lookup
        const reverseMapping = {};
        for (const base in mapping) {
            reverseMapping[mapping[base]] = base;
        }

        // Pad with '0' if length is odd to ensure 2-bit chunks
        const paddedBinary = binary.length % 2 === 1 ? binary + '0' : binary;

        for (let i = 0; i < paddedBinary.length; i += 2) {
            const twoBits = paddedBinary.substring(i, i + 2);
            const base = reverseMapping[twoBits];
            dna += base || 'X'; // Should always find a base if mapping is valid
        }
        return dna;
    }

    /**
     * Converts a DNA sequence string back to its full binary representation.
     * @param {string} dna
     * @param {object} mapping The DNA base to 2-bit mapping.
     * @returns {string} The concatenated binary string.
     */
    function dnaToBinary(dna, mapping) {
        let binary = '';
        for (let i = 0; i < dna.length; i++) {
            const base = dna[i];
            binary += mapping[base] || '';
        }
        return binary;
    }

    /**
     * Converts a binary string back into a human-readable text string.
     * @param {string} binary
     * @returns {string} The decoded text.
     */
    function binaryToText(binary) {
        let text = '';
        // Process in 8-bit chunks
        for (let i = 0; i < binary.length; i += 8) {
            const byte = binary.substring(i, i + 8);
            if (byte.length === 8) {
                // Convert 8-bit binary string to integer, then to character
                const charCode = parseInt(byte, 2);
                text += String.fromCharCode(charCode);
            }
        }
        return text;
    }

    // --- VISUALIZATION LOGIC ---

    /**
     * Draws the DNA sequence as colored blocks on the canvas.
     * @param {string} dnaSequence The sequence string to draw.
     */
    function drawSequence(dnaSequence) {
        if (!elements.ctx) return;

        const canvas = elements.dnaCanvas;
        canvas.width = canvas.clientWidth; // Adjust width to actual size
        canvas.height = 200; // Keep height constant for visual stability
        elements.ctx.clearRect(0, 0, canvas.width, canvas.height);

        const sequenceLength = dnaSequence.length;
        if (sequenceLength === 0) return;

        // Calculate block dimensions
        const margin = 5;
        const totalWidth = canvas.width - 2 * margin;
        const totalHeight = canvas.height - 2 * margin;

        const maxBlocks = Math.floor(totalWidth / 10); // Max blocks that fit (e.g., min block width 10px)
        const displayLength = Math.min(sequenceLength, 250); // Limit to 250 for performance and visual clarity
        const blockWidth = Math.floor(totalWidth / displayLength);
        const blockHeight = totalHeight;

        // Draw blocks
        for (let i = 0; i < displayLength; i++) {
            const base = dnaSequence[i];
            const color = COLOR_MAP[base] || '#374151'; // Default gray for 'X' or error
            const x = margin + i * blockWidth;

            elements.ctx.fillStyle = color;
            elements.ctx.fillRect(x, margin, blockWidth, blockHeight);
        }

        // Add a note if the sequence was truncated for display
        if (sequenceLength > displayLength) {
            elements.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            elements.ctx.font = '14px Arial';
            elements.ctx.textAlign = 'right';
            elements.ctx.fillText(`... ${sequenceLength - displayLength} more bases not shown`, canvas.width - margin - 5, canvas.height - 10);
        }
    }


    // --- EVENT HANDLERS ---

    /**
     * Handles the 'Encode & Visualize' / 'Re-Simulate' action.
     */
    function handleEncodeAndVisualize() {
        const text = elements.inputText.value;
        const newMapping = readCurrentMapping();

        if (!newMapping) {
            // Error already shown in readCurrentMapping
            return;
        }

        if (text.length === 0) {
            showStatus("Please enter text to encode.", 'error');
            return;
        }

        currentMapping = newMapping;

        try {
            // 1. Convert Text to Binary
            const binarySequence = textToBinary(text);

            // 2. Convert Binary to DNA
            const dna = binaryToDNA(binarySequence, currentMapping);
            currentDNASequence = dna;

            // 3. Update UI and Visualize
            elements.dnaSequenceOutput.textContent = dna;
            drawSequence(dna);
            elements.decodedTextOutput.textContent = 'Awaiting Decoding...'; // Reset decode output

            showStatus('Text successfully encoded and visualized!', 'success');
        } catch (error) {
            console.error(error);
            showStatus('An error occurred during encoding.', 'error');
        }
    }

    /**
     * Handles the 'Decode Sequence' action.
     */
    function handleDecode() {
        if (!currentDNASequence) {
            showStatus('Please run the "Encode & Visualize" step first.', 'error');
            return;
        }

        try {
            // 1. Convert DNA back to Binary using the current mapping
            const binarySequence = dnaToBinary(currentDNASequence, currentMapping);

            // 2. Convert Binary back to Text
            const decodedText = binaryToText(binarySequence);

            // 3. Update UI
            elements.decodedTextOutput.textContent = decodedText;

            // Check if decoding was perfect
            const originalText = elements.inputText.value;
            if (originalText === decodedText) {
                showStatus('Decoding successful! Original text was perfectly recovered.', 'success');
            } else {
                showStatus('Decoding finished. Check for potential padding or truncation issues.', 'success');
            }

        } catch (error) {
            console.error(error);
            showStatus('An error occurred during decoding.', 'error');
        }
    }

    // --- INITIALIZATION ---
    window.onload = function() {
        initMappingInputs();
        elements.ctx = elements.dnaCanvas.getContext('2d');

        // Initial run to show the default encoding
        handleEncodeAndVisualize();

        // Re-draw canvas on resize to maintain responsiveness
        window.addEventListener('resize', () => {
             if (currentDNASequence) {
                drawSequence(currentDNASequence);
             }
        });
    };
</script>

</body>
</html>
